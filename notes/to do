print out saturation even when --quiet is passed in

proof of grp196-1 has duplicate lemma numbers

proof simplification: if we have a chain of axioms/lemmas
  t = u = ... = v,
check to see if the lemma used to prove t = u also works for t = v.
(This helps with repeated terms in laws, as well as weak laws.)
Inline weak laws to help with this? Or maybe take the lemma
  t -> t'
and turn it into
  t -> t' -> rename(t)
and then fix up all uses of the lemma - the transformation above
should then clean up everything.

look at gt6 - ground joinability testing goes really slow
rob006-1 too

* adjust CP depth so that simplifications of rules get the same depth
  (maybe this is already the case)
* make sure that connectedness respects simplerThan
* use extra rules again [should be ok to rewrite one ground joinable
  term to a smaller one: instance of subconnectedness, or
  alternatively, if we have t -> v <- u and replace t with u then we
  could rewrite t to v before, and now we can rewrite t to u to v]
* check that details of simplerThan are correct
  (e.g., is it enough to check the rule in the orientation we are
  currently using it?) Why is it complete?

N.B. if we introduce goal-directness, we must NOT rewrite
terms t(..., X, ...) backwards with e.g. $equals(t,t)->$true,
letting X=$true. This is a type error really.
  * Maybe add narrowing before encoding types?

add extra rules:
if a rule is simplified away, keep it as an extra rule, in case of
case-split-on-not-vars note below (?)
maybe do that only if a rule is ground joined?

simplification: add complete version
plan: define total order on rules which is compatible with KBO
(i.e., order on orientable rules is defined by KBO); only rewrite wrt
lesser rules. Note: compatibility implies that we don't have to check
this condition when applying oriented rules, only unoriented.

re-add cancellative laws?

goal-directed: combine two rules with forward reasoning
(makes it easier to e.g. identify useful critical pairs)

CP compression for longer runs.
  * N.B. many rules get one of their CPs selected, so need compression
    of intervals. This may be because when a rule is created, it was
    head of the queue, and e.g. any CP with commutativity will have
    a similar weight.

Look into twee with boolean preconditions. (Also twee with theories.)

Work out why LAT044-1.p and BOO067-1.p have regressed.
BOO067-1 works with --no-simplify --no-ground-joining. Why?

It may be that:
  t = u is ground joinable
but we want to apply t_sigma = u_sigma in ground joining a later rule
and then we can't because it's not a case split on variables.
That suggests that we should case split on not-variables by replacing
them with uninterpreted variables temporarily.
